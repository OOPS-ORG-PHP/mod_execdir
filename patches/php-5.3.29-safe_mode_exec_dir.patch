diff -urNp php-5.3.29.org/ext/pcntl/pcntl.c php-5.3.29/ext/pcntl/pcntl.c
--- php-5.3.29.org/ext/pcntl/pcntl.c	2014-08-14 04:22:50.000000000 +0900
+++ php-5.3.29/ext/pcntl/pcntl.c	2016-06-18 05:20:06.880873197 +0900
@@ -46,6 +46,9 @@
 
 #include <errno.h>
 
+// from ext/standard/exec.c
+char *get_jailed_shell_cmd (char *);
+
 ZEND_DECLARE_MODULE_GLOBALS(pcntl)
 static PHP_GINIT_FUNCTION(pcntl);
 
@@ -751,13 +754,18 @@ PHP_FUNCTION(pcntl_exec)
 	int pair_length;
 	char *key;
 	uint key_length;
-	char *path;
+	char *path, *jpath = NULL;
 	int path_len;
 	ulong key_num;
 		
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|aa", &path, &path_len, &args, &envs) == FAILURE) {
 		return;
 	}
+
+	if (strlen(path) != path_len) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Cannot use '\\0' character on command");
+		RETURN_FALSE;
+	}
 	
 	if (ZEND_NUM_ARGS() > 1) {
 		/* Build argument list */
@@ -780,6 +788,8 @@ PHP_FUNCTION(pcntl_exec)
 		*(argv+1) = NULL;
 	}
 
+	jpath = get_jailed_shell_cmd(path);
+
 	if ( ZEND_NUM_ARGS() == 3 ) {
 		/* Build environment pair list */
 		envs_hash = HASH_OF(envs);
@@ -814,7 +824,8 @@ PHP_FUNCTION(pcntl_exec)
 		}
 		*(pair) = NULL;
 
-		if (execve(path, argv, envp) == -1) {
+		if (execve(jpath, argv, envp) == -1) {
+			efree(jpath);
 			PCNTL_G(last_error) = errno;
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error has occured: (errno %d) %s", errno, strerror(errno));
 		}
@@ -824,12 +835,14 @@ PHP_FUNCTION(pcntl_exec)
 		efree(envp);
 	} else {
 
-		if (execv(path, argv) == -1) {
+		if (execv(jpath, argv) == -1) {
+			efree(jpath);
 			PCNTL_G(last_error) = errno;
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error has occured: (errno %d) %s", errno, strerror(errno));
 		}
 	}
 
+	efree(jpath);
 	efree(argv);
 	
 	RETURN_FALSE;
diff -urNp php-5.3.29.org/ext/standard/exec.c php-5.3.29/ext/standard/exec.c
--- php-5.3.29.org/ext/standard/exec.c	2014-08-14 04:22:50.000000000 +0900
+++ php-5.3.29/ext/standard/exec.c	2016-06-18 05:20:06.880873197 +0900
@@ -63,7 +63,7 @@ PHPAPI int php_exec(int type, char *cmd,
 	FILE *fp;
 	char *buf, *tmp=NULL;
 	int l = 0, pclose_return;
-	char *cmd_p, *b, *c, *d=NULL;
+	char *cmd_p, *b=NULL, *c, *d=NULL;
 	php_stream *stream;
 	size_t buflen, bufl = 0;
 #if PHP_SIGCHILD
@@ -97,7 +97,8 @@ PHPAPI int php_exec(int type, char *cmd,
 		efree(d);
 		d = cmd_p;
 	} else {
-		cmd_p = cmd;
+		cmd_p = get_jailed_shell_cmd (cmd);
+		d = cmd_p;
 	}
 
 #if PHP_SIGCHILD
@@ -227,6 +228,11 @@ static void php_exec_ex(INTERNAL_FUNCTIO
 		RETURN_FALSE;
 	}
 
+	if (strlen(cmd) != cmd_len) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Cannot use '\\0' character on command");
+		RETURN_FALSE;
+	}
+
 	if (!ret_array) {
 		ret = php_exec(mode, cmd, NULL, return_value TSRMLS_CC);
 	} else {
@@ -429,6 +435,343 @@ PHPAPI char *php_escape_shell_arg(char *
 }
 /* }}} */
 
+/* {{{ get_jailed_shell_cmd
+ */
+char *get_jailed_shell_cmd (char *cmd) {
+	size_t exec_len;
+	char *_cmd;
+
+	exec_len = strlen (PG(safe_mode_exec_dir));
+
+	if ( exec_len ) {
+		char *b = NULL, *c = NULL;
+		char *tmp;
+		char *__cmd;
+		size_t c_len = 0;
+
+		c = strchr (cmd, ' ');
+		if ( c ) {
+			c_len = strlen (c);
+			*c = 0;
+		}
+
+		//php_printf ("g --> %s : %s : %s : '%c'\n", c, b, PG(safe_mode_exec_dir), PHP_DIR_SEPARATOR);
+		//php_printf ("g ==> %s\n", cmd);
+
+		tmp = estrdup (cmd);
+		b = strrchr (tmp, '/');
+
+		if ( c ) *c = ' ';
+
+		if ( b )
+			c_len = sizeof (char *) * (strlen (b) + c_len + 1);
+		else
+			c_len = sizeof (char *) * (strlen (tmp) + c_len + 1);
+
+		__cmd = emalloc (c_len);
+		memset (__cmd, 0, c_len);
+		if ( c )
+			sprintf (__cmd, "%s%s", b ? b : tmp, c);
+		else {
+			if ( b )
+				memcpy (__cmd, b, strlen (b));
+			else
+				memcpy (__cmd, tmp, strlen (tmp));
+		}
+		efree (tmp);
+		_cmd = php_jailed_shell_cmd (__cmd, PG(safe_mode_exec_dir));
+
+	} else {
+		_cmd = estrdup (cmd);
+	}
+
+	//php_printf ("g **> %s\n", _cmd);
+
+	return _cmd;
+}
+/* }}} */
+
+/* {{{ check_quote_block
+ * case by single quote or double quote
+ * single quote (')  is digit 39
+ * double quote (")  is digit 34
+ * reverse slash (\) is digit 92
+ */
+int check_quote_block (struct quote_chk_char qc, struct quote_value *_qv) {
+	if ( qc.cur != 39 && qc.cur != 34 ) {
+		switch (qc.cur) {
+			case ';' :
+			case '|' :
+			case '`' :
+			case '$' :
+			case '&' :
+				if ( qc.mcur == 92 )
+					return 0;
+
+				if ( _qv->quote > 0 ) {
+					if ( _qv->dquote ) {
+						if ( _qv->bquote )
+							return 0;
+						else if ( _qv->daquote )
+							return 0;
+					}
+
+					return 1;
+				}
+		}
+		return 0;
+	}
+
+	if ( qc.mcur == 92 )
+		return 0;
+
+	if ( _qv->quote > 0 ) {
+		if ( qc.cur == 34 ) {
+			if ( _qv->squote ) return 0;
+		} else {
+			if ( _qv->dquote ) return 0;
+		}
+
+		_qv->quote  = 0;
+		_qv->squote = 0;
+		_qv->dquote = 0;
+	} else {
+		_qv->quote = 1;
+		if ( qc.cur == 34 ) {
+			_qv->dquote = 1;
+			_qv->squote = 0;
+		} else {
+			_qv->dquote = 0;
+			_qv->squote = 1;
+		}
+	}
+
+	return 0;
+}
+/* }}} */
+
+/* {{{ php_jailed_shell_cmd
+ */
+char *php_jailed_shell_cmd (char *cmd, char *path) {
+	int cmd_len  = 0;
+	int path_len = 0;
+	int buf_len  = 0;
+	int ep = 0;
+	int i, j, b, _len = 0;
+	char *buf;
+	char *_cmd, *x_cmd, *debug_cmd;
+	char *_path, *_tpath;
+	int _start;
+	int debug = 0;
+	struct quote_value qv = { 0, 0, 0, 0, 0 };
+	struct quote_chk_char qc;
+
+	cmd_len = strlen (cmd);
+	debug_cmd = emalloc (sizeof (char *) * cmd_len + 1);
+	memset (debug_cmd, 0, cmd_len);
+	if ( ! strncmp ("DEBUG:", cmd, 6) ) {
+		debug = 1;
+		memcpy (debug_cmd, cmd + 6, cmd_len - 6);
+	} else if ( ! strncmp ("DDEBUG:", cmd, 7) ) {
+		debug = 2;
+		memcpy (debug_cmd, cmd + 7, cmd_len - 7);
+	} else {
+		debug_cmd = estrdup (cmd);
+	}
+
+	_tpath = php_trim (path, strlen (path), NULL, 0, NULL, 3 TSRMLS_CC);
+	x_cmd = php_trim (debug_cmd, strlen (debug_cmd), NULL, 0, NULL, 3 TSRMLS_CC);
+	_cmd = ( x_cmd[0] == '/' ) ? estrdup (x_cmd + 1) : estrdup (x_cmd);
+	efree (x_cmd);
+	efree (debug_cmd);
+
+	cmd_len  = strlen(_cmd);
+	path_len = strlen (_tpath);
+
+	if ( path_len == 1 )
+		b = ( _tpath == "/" ) ? 0 : 1;
+	else if ( _tpath[path_len - 1] != '/' )
+		b = 1;
+	else
+		b = 0;
+
+	_path= emalloc (sizeof (char *) * (cmd_len + 2));
+	memset (_path, 0, sizeof (char *) * (cmd_len + 2));
+	sprintf (_path, "%s%s", _tpath, !b ? "" : "/");
+	path_len = strlen (_path);
+	efree (_tpath);
+
+	for ( i=0; i<cmd_len; i++ ) {
+		switch (_cmd[i]) {
+			case ';' :
+			case '|' :
+			case '`' :
+			case '$' :
+			case '&' :
+				_len++;
+				break;
+		}
+	}
+
+	_len++;
+	buf_len = sizeof (char *) * (cmd_len + ((path_len + 2) * _len));
+	buf = emalloc (buf_len);
+	memset (buf, 0, buf_len);
+
+	memcpy (buf, _path, path_len);
+	ep = strlen (buf);
+
+	_len      = 0;
+	_start    = 0;
+
+	if ( debug )
+		php_printf ("p **> %s\n", _cmd);
+
+	for ( i=0; i<cmd_len; i++ ) {
+roopstart:
+		if ( debug > 1 ) {
+			php_printf ("#### "
+						"_cmd[i] => %c : "
+						"i => %2d : "
+						"cmd_len => %2d : "
+						"_start => %2d : "
+						"quote => %2d : "
+						"squote => %2d : "
+						"dquote => %2d : "
+						"bquote => %2d : "
+						"daquote => %2d\n",
+						_cmd[i], i, cmd_len, _start,
+						qv.quote, qv.squote, qv.dquote, qv.bquote, qv.daquote);
+		}
+
+		qc.mcur = _cmd[i-1];
+		qc.cur  = _cmd[i];
+		qc.acur = _cmd[i+1];
+
+		if ( qc.mcur != '\\' && qc.cur == '`' ) {
+			if ( ! qv.bquote ) qv.bquote = 1;
+			else qv.bquote = 0;
+		}
+
+		if ( qc.mcur != '\\' && qc.cur == '$' && qc.acur == '(' ) {
+			qv.daquote = 1;
+		} else if ( qv.daquote && qc.mcur != '\\' && qc.cur == ')' ) {
+			qv.daquote = 0;
+		}
+
+		if ( i == cmd_len - 1 && _start <= i ) {
+			memcpy (buf + ep, _cmd + _start, i - _start + 1);
+			break;
+		}
+
+		if ( check_quote_block (qc, &qv) ) {
+			i++;
+			goto roopstart;
+		}
+
+		switch (_cmd[i]) {
+			case ';' :
+			case '|' :
+			case '`' :
+			case '$' :
+			case '&' :
+				if ( _cmd[i-1] == '\\' ) {
+					i++;
+					goto roopstart;
+				}
+
+				memcpy (buf + ep, _cmd + _start, i - _start + 1);
+				_start = i + 1;
+				ep = strlen (buf);
+
+				/*
+				if ( _cmd[i] == '`' && ! qv.bquote ) qv.bquote = 1;
+				else if ( _cmd[i] == '`' && qv.bquote ) {
+					qv.bquote = 0;
+					i++;
+
+					goto roopstart;
+				}
+				*/
+				if ( _cmd[i] == '`' && ! qv.bquote ) {
+					i++;
+					goto roopstart;
+				}
+
+				// if not case of $() or && or ||, skip
+				if ( _cmd[i] == '$' && _cmd[i+1] != '(' ) {
+					i++;
+					goto roopstart;
+				}
+
+				// if case of `` or ;; that include any charactors, skip
+				if ( (_cmd[i] == ';' && _cmd[i+1] == ';') || (_cmd[i] == '`' && _cmd[i+1] == '`') ) {
+					i++;
+					goto roopstart;
+				}
+
+				i++;
+				if ( (_cmd[i] == '(' && _cmd[i-1] == '$') || (_cmd[i] == '&' && _cmd[i-1] == '&') ||
+					 (_cmd[i] == '|' && _cmd[i-1] == '|') ) {
+					memset (buf + ep, _cmd[i], 1);
+					_start++;
+					ep++;
+					i++;
+				}
+
+				for ( j=i; j<cmd_len; j++ ) {
+					// blank ( ) => 32
+					// tab (\t)  => 9
+					if ( _cmd[j] == 32 || _cmd[j] == 9 ) {
+						memset (buf + ep, _cmd[j], 1);
+						_start++;
+						ep++;
+						i++;
+					} else {
+						int y;
+						int _vcmd_len = 0;
+						char vcmd[256] = { 0, };
+						char *_vcmd = NULL;
+						char *_tvcmd = NULL;
+
+						for ( y=j; y<cmd_len; y++ ) {
+							// blank ( ) => 32
+							// tab (\t)  => 9
+							if ( _cmd[y] == 32 || _cmd[y] == 9 || (qv.bquote && _cmd[y] == '`') ) {
+									memcpy (vcmd, _cmd + j, y - j );
+									_tvcmd = strrchr (vcmd, '/');
+									_vcmd = _tvcmd ? _tvcmd + 1 : vcmd;
+									_vcmd_len = strlen (_vcmd);
+									i = y;
+
+									//php_printf ("***** => %s : %s, %d, %d\n", vcmd, _vcmd, qv.bquote, i);
+									if ( _cmd[y] == '`' )
+										 qv.bquote = 0;
+
+									break;
+							}
+						}
+						memcpy (buf + ep, _path, path_len);
+						memcpy (buf + ep + path_len, _vcmd, _vcmd_len);
+						ep += path_len + _vcmd_len;
+						_start = i;
+						break;
+					}
+				}
+				break;
+		}
+	}
+
+	if ( debug )
+		 php_printf ("p ==> %s\n--\n", buf);
+
+	efree (_cmd);
+	efree (_path);
+
+	return buf; 
+}
+/* }}} */
+
 /* {{{ proto string escapeshellcmd(string command)
    Escape shell metacharacters */
 PHP_FUNCTION(escapeshellcmd)
@@ -478,6 +821,7 @@ PHP_FUNCTION(shell_exec)
 	char *command;
 	int command_len;
 	char *ret;
+	char *jcommand;
 	php_stream *stream;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &command, &command_len) == FAILURE) {
@@ -489,14 +833,22 @@ PHP_FUNCTION(shell_exec)
 		RETURN_FALSE;
 	}
 
+	if (strlen(command) != command_len) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Cannot use '\\0' character on command");
+		RETURN_FALSE;
+	}
+
+	jcommand = get_jailed_shell_cmd (command);
 #ifdef PHP_WIN32
-	if ((in=VCWD_POPEN(command, "rt"))==NULL) {
+	if ((in=VCWD_POPEN(jcommand, "rt"))==NULL) {
 #else
-	if ((in=VCWD_POPEN(command, "r"))==NULL) {
+	if ((in=VCWD_POPEN(jcommand, "r"))==NULL) {
 #endif
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to execute '%s'", command);
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to execute '%s'", jcommand);
+		efree (jcommand);
 		RETURN_FALSE;
 	}
+	efree (jcommand);
 
 	stream = php_stream_fopen_from_pipe(in, "rb");
 	total_readbytes = php_stream_copy_to_mem(stream, &ret, PHP_STREAM_COPY_ALL, 0);
diff -urNp php-5.3.29.org/ext/standard/exec.h php-5.3.29/ext/standard/exec.h
--- php-5.3.29.org/ext/standard/exec.h	2014-08-14 04:22:50.000000000 +0900
+++ php-5.3.29/ext/standard/exec.h	2016-06-18 05:20:06.881873251 +0900
@@ -34,8 +34,25 @@ PHP_FUNCTION(proc_terminate);
 PHP_FUNCTION(proc_nice);
 PHP_MINIT_FUNCTION(proc_open);
 
+struct quote_value {
+	int quote;
+	int squote;
+	int dquote;
+	int bquote;
+	int daquote;
+};
+
+struct quote_chk_char {
+	char mcur;
+	char cur;
+	char acur;
+};
+
 PHPAPI char *php_escape_shell_cmd(char *);
 PHPAPI char *php_escape_shell_arg(char *);
+char *get_jailed_shell_cmd (char *);
+char *php_jailed_shell_cmd (char *, char *);
+int check_quote_block (struct quote_chk_char, struct quote_value *);
 PHPAPI int php_exec(int type, char *cmd, zval *array, zval *return_value TSRMLS_DC);
 
 #endif /* EXEC_H */
diff -urNp php-5.3.29.org/ext/standard/file.c php-5.3.29/ext/standard/file.c
--- php-5.3.29.org/ext/standard/file.c	2014-08-14 04:22:50.000000000 +0900
+++ php-5.3.29/ext/standard/file.c	2016-06-18 05:20:06.882873305 +0900
@@ -978,6 +978,11 @@ PHP_FUNCTION(popen)
 		return;
 	}
 
+	if (strlen(command) != command_len) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Cannot use '\\0' character on command");
+		RETURN_FALSE;
+	}
+
 	posix_mode = estrndup(mode, mode_len);
 #ifndef PHP_WIN32
 	{
@@ -1023,7 +1028,10 @@ PHP_FUNCTION(popen)
 		efree(buf);
 
 	} else {
-		fp = VCWD_POPEN(command, posix_mode);
+		tmp = get_jailed_shell_cmd (command);
+		fp = VCWD_POPEN(tmp, posix_mode);
+		efree (tmp);
+
 		if (!fp) {
 			php_error_docref2(NULL TSRMLS_CC, command, posix_mode, E_WARNING, "%s", strerror(errno));
 			efree(posix_mode);
diff -urNp php-5.3.29.org/ext/standard/proc_open.c php-5.3.29/ext/standard/proc_open.c
--- php-5.3.29.org/ext/standard/proc_open.c	2014-08-14 04:22:50.000000000 +0900
+++ php-5.3.29/ext/standard/proc_open.c	2016-06-18 05:20:06.882873305 +0900
@@ -283,7 +283,8 @@ static int php_make_safe_mode_command(ch
 	char *space, *sep, *arg0;
 
 	if (!PG(safe_mode)) {
-		*safecmd = pestrdup(cmd, is_persistent);
+		//*safecmd = pestrdup(cmd, is_persistent);
+		*safecmd = get_jailed_shell_cmd (cmd);
 		return SUCCESS;
 	}
 
@@ -538,6 +539,11 @@ PHP_FUNCTION(proc_open)
 		RETURN_FALSE;
 	}
 
+	if (strlen(command) != command_len) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Cannot use '\\0' character on command");
+		RETURN_FALSE;
+	}
+
 	if (FAILURE == php_make_safe_mode_command(command, &command, is_persistent TSRMLS_CC)) {
 		RETURN_FALSE;
 	}
